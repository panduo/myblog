{"meta":{"title":"潘铎的个人博客","subtitle":null,"description":null,"author":"潘铎","url":""},"pages":[],"posts":[{"title":"websocket/php网页聊天室(代码源自网上/出处不明)","slug":"websocket-php网页聊天室","date":"2017-05-04T09:15:46.000Z","updated":"2017-05-04T09:22:26.000Z","comments":true,"path":"04/websocket-php网页聊天室/","link":"","permalink":"/04/websocket-php网页聊天室/","excerpt":"","text":"HTML123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\"&gt; &lt;style&gt; p &#123; text-align: left; padding-left: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div style=\"width: 800px;height: 600px;margin: 30px auto;text-align: center\"&gt; &lt;h1&gt;websocket聊天室&lt;/h1&gt; &lt;div style=\"width: 800px;border: 1px solid gray;height: 300px;\"&gt; &lt;div style=\"width: 200px;height: 300px;float: left;text-align: left;\"&gt; &lt;p&gt;&lt;span&gt;当前在线:&lt;/span&gt;&lt;span id=\"user_num\"&gt;0&lt;/span&gt;&lt;/p&gt; &lt;div id=\"user_list\" style=\"overflow: auto;\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=\"msg_list\" style=\"width: 598px;border: 1px solid gray; height: 300px;overflow: scroll;float: left;\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;br&gt; &lt;textarea id=\"msg_box\" rows=\"6\" cols=\"50\" onkeydown=\"confirm(event)\"&gt;&lt;/textarea&gt;&lt;br&gt; &lt;input type=\"button\" value=\"发送\" onclick=\"send()\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script type=\"text/javascript\"&gt; // 存储用户名到全局变量,握手成功后发送给服务器 var uname = prompt('请输入用户名', 'user' + uuid(8, 16)); var ws = new WebSocket(\"ws://127.0.0.1:8888\"); console.log(ws); ws.onopen = function () &#123; var data = \"系统消息：建立连接成功\"; listMsg(data); &#125;; /** * 分析服务器返回信息 * * msg.type : user 普通信息;system 系统信息;handshake 握手信息;login 登陆信息; logout 退出信息; * msg.from : 消息来源 * msg.content: 消息内容 */ ws.onmessage = function (e) &#123; var msg = JSON.parse(e.data); var sender, user_name, name_list, change_type; switch (msg.type) &#123; case 'system': sender = '系统消息: '; break; case 'user': sender = msg.from + ': '; break; case 'handshake': var user_info = &#123;'type': 'login', 'content': uname&#125;; sendMsg(user_info); return; case 'login': case 'logout': user_name = msg.content; name_list = msg.user_list; change_type = msg.type; dealUser(user_name, change_type, name_list); return; &#125; var data = sender + msg.content; listMsg(data); &#125;; ws.onerror = function () &#123; var data = \"系统消息 : 出错了,请退出重试.\"; listMsg(data); &#125;; /** * 在输入框内按下回车键时发送消息 * * @param event * * @returns &#123;boolean&#125; */ function confirm(event) &#123; var key_num = event.keyCode; if (13 == key_num) &#123; send(); &#125; else &#123; return false; &#125; &#125; /** * 发送并清空消息输入框内的消息 */ function send() &#123; var msg_box = document.getElementById(\"msg_box\"); var content = msg_box.value; var reg = new RegExp(\"\\r\\n\", \"g\"); content = content.replace(reg, \"\"); var msg = &#123;'content': content.trim(), 'type': 'user'&#125;; sendMsg(msg); msg_box.value = ''; // todo 清除换行符 &#125; /** * 将消息内容添加到输出框中,并将滚动条滚动到最下方 */ function listMsg(data) &#123; var msg_list = document.getElementById(\"msg_list\"); var msg = document.createElement(\"p\"); msg.innerHTML = data; msg_list.appendChild(msg); msg_list.scrollTop = msg_list.scrollHeight; &#125; /** * 处理用户登陆消息 * * @param user_name 用户名 * @param type login/logout * @param name_list 用户列表 */ function dealUser(user_name, type, name_list) &#123; var user_list = document.getElementById(\"user_list\"); var user_num = document.getElementById(\"user_num\"); while(user_list.hasChildNodes()) &#123; user_list.removeChild(user_list.firstChild); &#125; for (var index in name_list) &#123; var user = document.createElement(\"p\"); user.innerHTML = name_list[index]; user_list.appendChild(user); &#125; user_num.innerHTML = name_list.length; user_list.scrollTop = user_list.scrollHeight; var change = type == 'login' ? '上线' : '下线'; var data = '系统消息: ' + user_name + ' 已' + change; listMsg(data); &#125; /** * 将数据转为json并发送 * @param msg */ function sendMsg(msg) &#123; var data = JSON.stringify(msg); ws.send(data); &#125; /** * 生产一个全局唯一ID作为用户名的默认值; * * @param len * @param radix * @returns &#123;string&#125; */ function uuid(len, radix) &#123; var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''); var uuid = [], i; radix = radix || chars.length; if (len) &#123; for (i = 0; i &lt; len; i++) uuid[i] = chars[0 | Math.random() * radix]; &#125; else &#123; var r; uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-'; uuid[14] = '4'; for (i = 0; i &lt; 36; i++) &#123; if (!uuid[i]) &#123; r = 0 | Math.random() * 16; uuid[i] = chars[(i == 19) ? (r &amp; 0x3) | 0x8 : r]; &#125; &#125; &#125; return uuid.join(''); &#125;&lt;/script&gt; PHP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308&lt;?phperror_reporting(E_ALL);set_time_limit(0);// 设置超时时间为无限,防止超时date_default_timezone_set('Asia/shanghai');class WebSocket &#123; const LOG_PATH = '/tmp/'; const LISTEN_SOCKET_NUM = 9; /** * @var array $sockets * [ * (int)$socket =&gt; [ * info * ] * ] * todo 解释socket与file号对应 */ private $sockets = []; private $master; public function __construct($host, $port) &#123; try &#123; $this-&gt;master = socket_create(AF_INET, SOCK_STREAM, SOL_TCP); // 设置IP和端口重用,在重启服务器后能重新使用此端口; socket_set_option($this-&gt;master, SOL_SOCKET, SO_REUSEADDR, 1); // 将IP和端口绑定在服务器socket上; socket_bind($this-&gt;master, $host, $port); // listen函数使用主动连接套接口变为被连接套接口，使得一个进程可以接受其它进程的请求， //从而成为一个服务器进程。在TCP服务器编程中listen函数把进程变为一个服务器， //并指定相应的套接字变为被动连接,其中的能存储的请求不明的socket数目。 socket_listen($this-&gt;master, self::LISTEN_SOCKET_NUM); &#125; catch (\\Exception $e) &#123; $err_code = socket_last_error(); $err_msg = socket_strerror($err_code); $this-&gt;error([ 'error_init_server', $err_code, $err_msg ]); &#125; $this-&gt;sockets[0] = ['resource' =&gt; $this-&gt;master]; $pid = posix_getpid(); $this-&gt;debug([\"server: &#123;$this-&gt;master&#125; started,pid: &#123;$pid&#125;\"]); while (true) &#123; try &#123; $this-&gt;doServer(); &#125; catch (\\Exception $e) &#123; $this-&gt;error([ 'error_do_server', $e-&gt;getCode(), $e-&gt;getMessage() ]); &#125; &#125; &#125; private function doServer() &#123; $write = $except = NULL; $sockets = array_column($this-&gt;sockets, 'resource'); $read_num = socket_select($sockets, $write, $except, NULL); // select作为监视函数,参数分别是(监视可读,可写,异常,超时时间),返回可操作数目,出错时返回false; if (false === $read_num) &#123; $this-&gt;error([ 'error_select', $err_code = socket_last_error(), socket_strerror($err_code) ]); return; &#125; foreach ($sockets as $socket) &#123; // 如果可读的是服务器socket,则处理连接逻辑 if ($socket == $this-&gt;master) &#123; $client = socket_accept($this-&gt;master); // 创建,绑定,监听后accept函数将会接受socket要来的连接, //一旦有一个连接成功,将会返回一个新的socket资源用以交互,如果是一个多个连接的队列, //只会处理第一个,如果没有连接的话,进程将会被阻塞,直到连接上. //如果用set_socket_blocking或socket_set_noblock()设置了阻塞, //会返回false;返回资源后,将会持续等待连接。 if (false === $client) &#123; $this-&gt;error([ 'err_accept', $err_code = socket_last_error(), socket_strerror($err_code) ]); continue; &#125; else &#123; self::connect($client); continue; &#125; &#125; else &#123; // 如果可读的是其他已连接socket,则读取其数据,并处理应答逻辑 $bytes = @socket_recv($socket, $buffer, 2048, 0); if ($bytes &lt; 9) &#123; $recv_msg = $this-&gt;disconnect($socket); &#125; else &#123; if (!$this-&gt;sockets[(int)$socket]['handshake']) &#123; self::handShake($socket, $buffer); continue; &#125; else &#123; $recv_msg = self::parse($buffer); &#125; &#125; array_unshift($recv_msg, 'receive_msg'); $msg = self::dealMsg($socket, $recv_msg); $this-&gt;broadcast($msg); &#125; &#125; &#125; /** * 将socket添加到已连接列表,但握手状态留空; * * @param $socket */ public function connect($socket) &#123; socket_getpeername($socket, $ip, $port); $socket_info = [ 'resource' =&gt; $socket, 'uname' =&gt; '', 'handshake' =&gt; false, 'ip' =&gt; $ip, 'port' =&gt; $port, ]; $this-&gt;sockets[(int)$socket] = $socket_info; $this-&gt;debug(array_merge(['socket_connect'], $socket_info)); &#125; /** * 客户端关闭连接 * * @param $socket * * @return array */ private function disconnect($socket) &#123; $recv_msg = [ 'type' =&gt; 'logout', 'content' =&gt; $this-&gt;sockets[(int)$socket]['uname'], ]; unset($this-&gt;sockets[(int)$socket]); return $recv_msg; &#125; /** * 用公共握手算法握手 * * @param $socket * @param $buffer * * @return bool */ public function handShake($socket, $buffer) &#123; // 获取到客户端的升级密匙 $line_with_key = substr($buffer, strpos($buffer, 'Sec-WebSocket-Key:') + 18); $key = trim(substr($line_with_key, 0, strpos($line_with_key, \"\\r\\n\"))); // 生成升级密匙,并拼接websocket升级头 $upgrade_key = base64_encode(sha1($key . \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\", true)); // 升级key的算法 $upgrade_message = \"HTTP/1.1 101 Switching Protocols\\r\\n\"; $upgrade_message .= \"Upgrade: websocket\\r\\n\"; $upgrade_message .= \"Sec-WebSocket-Version: 13\\r\\n\"; $upgrade_message .= \"Connection: Upgrade\\r\\n\"; $upgrade_message .= \"Sec-WebSocket-Accept:\" . $upgrade_key . \"\\r\\n\\r\\n\"; socket_write($socket, $upgrade_message, strlen($upgrade_message));// 向socket里写入升级信息 $this-&gt;sockets[(int)$socket]['handshake'] = true; socket_getpeername($socket, $ip, $port); $this-&gt;debug([ 'hand_shake', $socket, $ip, $port ]); // 向客户端发送握手成功消息,以触发客户端发送用户名动作; $msg = [ 'type' =&gt; 'handshake', 'content' =&gt; 'done', ]; $msg = $this-&gt;build(json_encode($msg)); socket_write($socket, $msg, strlen($msg)); return true; &#125; /** * 解析数据 * * @param $buffer * * @return bool|string */ private function parse($buffer) &#123; $decoded = ''; $len = ord($buffer[1]) &amp; 127; if ($len === 126) &#123; $masks = substr($buffer, 4, 4); $data = substr($buffer, 8); &#125; else if ($len === 127) &#123; $masks = substr($buffer, 10, 4); $data = substr($buffer, 14); &#125; else &#123; $masks = substr($buffer, 2, 4); $data = substr($buffer, 6); &#125; for ($index = 0; $index &lt; strlen($data); $index++) &#123; $decoded .= $data[$index] ^ $masks[$index % 4]; &#125; return json_decode($decoded, true); &#125; /** * 将普通信息组装成websocket数据帧 * * @param $msg * * @return string */ private function build($msg) &#123; $frame = []; $frame[0] = '81'; $len = strlen($msg); if ($len &lt; 126) &#123; $frame[1] = $len &lt; 16 ? '0' . dechex($len) : dechex($len); &#125; else if ($len &lt; 65025) &#123; $s = dechex($len); $frame[1] = '7e' . str_repeat('0', 4 - strlen($s)) . $s; &#125; else &#123; $s = dechex($len); $frame[1] = '7f' . str_repeat('0', 16 - strlen($s)) . $s; &#125; $data = ''; $l = strlen($msg); for ($i = 0; $i &lt; $l; $i++) &#123; $data .= dechex(ord($msg&#123;$i&#125;)); &#125; $frame[2] = $data; $data = implode('', $frame); return pack(\"H*\", $data); &#125; /** * 拼装信息 * * @param $socket * @param $recv_msg * [ * 'type'=&gt;user/login * 'content'=&gt;content * ] * * @return string */ private function dealMsg($socket, $recv_msg) &#123; $msg_type = $recv_msg['type']; $msg_content = $recv_msg['content']; $response = []; switch ($msg_type) &#123; case 'login': $this-&gt;sockets[(int)$socket]['uname'] = $msg_content; // 取得最新的名字记录 $user_list = array_column($this-&gt;sockets, 'uname'); $response['type'] = 'login'; $response['content'] = $msg_content; $response['user_list'] = $user_list; break; case 'logout': $user_list = array_column($this-&gt;sockets, 'uname'); $response['type'] = 'logout'; $response['content'] = $msg_content; $response['user_list'] = $user_list; break; case 'user': $uname = $this-&gt;sockets[(int)$socket]['uname']; $response['type'] = 'user'; $response['from'] = $uname; $response['content'] = $msg_content; break; &#125; return $this-&gt;build(json_encode($response)); &#125; /** * 广播消息 * * @param $data */ private function broadcast($data) &#123; foreach ($this-&gt;sockets as $socket) &#123; if ($socket['resource'] == $this-&gt;master) &#123; continue; &#125; socket_write($socket['resource'], $data, strlen($data)); &#125; &#125; /** * 记录debug信息 * * @param array $info */ private function debug(array $info) &#123; $time = date('Y-m-d H:i:s'); array_unshift($info, $time); $info = array_map('json_encode', $info); file_put_contents(self::LOG_PATH . 'websocket_debug.log', implode(' | ', $info) . \"\\r\\n\", FILE_APPEND); &#125; /** * 记录错误信息 * * @param array $info */ private function error(array $info) &#123; $time = date('Y-m-d H:i:s'); array_unshift($info, $time); $info = array_map('json_encode', $info); file_put_contents(self::LOG_PATH . 'websocket_error.log', implode(' | ', $info) . \"\\r\\n\", FILE_APPEND); &#125;&#125;$ws = new WebSocket(\"127.0.0.1\", \"8888\");","categories":[],"tags":[]},{"title":"PHP性能分析工具:xhprof","slug":"PHP性能分析工具-xhprof","date":"2017-05-04T08:19:00.000Z","updated":"2017-05-04T09:09:37.000Z","comments":true,"path":"04/PHP性能分析工具-xhprof/","link":"","permalink":"/04/PHP性能分析工具-xhprof/","excerpt":"","text":"安装下载 http://pecl.php.net/get/xhprof-0.9.3.tgz 解压123456$ cd ~/Download/xhprof/.../extension$ /.../phpize$ ./configure --whith-php-config=/.../php-config$ make$ make test$ sudo make install 配置php.ini将.so扩展加入另加入 xhprof.output_dir=/tmp/xhprof //xhprof的分析日志目录 重启apache 查看phpinfo 使用把源码包中的 xhprof_html 和 xhprof_lib 文件夹拷贝到自己的监控项目中 如~/Sites/xhprof 12345678910111213141516171819xhprof_enable(); //开启监测 //xhprof_enable(XHPROF_FLAGS_NO_BUILTINS); 不记录内置的函数 //xhprof_enable(XHPROF_FLAGS_CPU + XHPROF_FLAGS_MEMORY); 同时分析CPU和Mem的开销 //要测试的代码&#123; xxx&#125;$xhprof_data = xhprof_disable(); //停止监测，返回运行数据$xhprof_root = '~/Sites/xhprof/'; include_once $xhprof_root.\"xhprof_lib/utils/xhprof_lib.php\"; include_once $xhprof_root.\"xhprof_lib/utils/xhprof_runs.php\"; $xhprof_runs = new XHProfRuns_Default(); $run_id = $xhprof_runs-&gt;save_run($xhprof_data, \"xhprof\");echo '&lt;a href=\"http://localhost/xhprof/xhprof_html/index.php?run='.$run_id.'&amp;source=xhprof\" target=\"_blank\"&gt;xhprof统计&lt;/a&gt;'; 名词解释： Function Name 函数名– Calls 调用次数– Calls% 调用百分比– Incl. Wall Time (microsec) 调用的包括子函数所有花费时间 以微秒算(一百万分之一秒)– IWall% 调用的包括子函数所有花费时间的百分比– Excl. Wall Time (microsec) 函数执行本身花费的时间，不包括子树执行时间,以微秒算(一百万分之一秒)– EWall% 函数执行本身花费的时间的百分比，不包括子树执行时间– Incl. CPU(microsecs) 调用的包括子函数所有花费的cpu时间。减Incl. Wall Time即为等待cpu的时间&emsp;&emsp;减Excl. Wall Time即为等待cpu的时间– ICpu% Incl. CPU(microsecs)的百分比– Excl. CPU(microsec) 函数执行本身花费的cpu时间，不包括子树执行时间,以微秒算(一百万分之一秒)。– ECPU% Excl. CPU(microsec)的百分比– Incl.MemUse(bytes) 包括子函数执行使用的内存。– IMemUse% Incl.MemUse(bytes)的百分比– Excl.MemUse(bytes) 函数执行本身内存,以字节算– EMemUse% Excl.MemUse(bytes)的百分比– Incl.PeakMemUse(bytes) Incl.MemUse的峰值– IPeakMemUse% Incl.PeakMemUse(bytes) 的峰值百分比– Excl.PeakMemUse(bytes) Excl.MemUse的峰值– EPeakMemUse% EMemUse% 峰值百分比 效果 安装gd库若[View Full CallGraph]点击报错,则可能是因为本机未安装graphviz库1$ brew install graphviz View Full Callgraph 注入项目在项目唯一入口处添加如下代码xhprof_enable(XHPROF_FLAGS_MEMORY | XHPROF_FLAGS_CPU);//在程序结束后收集数据register_shutdown_function(function() { $xhprof_data = xhprof_disable(); //让数据收集程序在后台运行 if (function_exists(‘fastcgi_finish_request’)) { fastcgi_finish_request(); } //保存xhprof数据}); 也可以将此段逻辑写入一个php文件如：~/Sites/inject.php,编辑php.ini 配置auto_prepend_file = ~/Sites/inject.php 重启apache 或使用nginx: fastcgi_param PHP_VALUE “auto_prepend_file=~/Sites/inject.php”; 此时每次访问均会自动加载性能分析","categories":[],"tags":[]},{"title":"./configure参数记录","slug":"configure参数记录","date":"2017-05-04T07:56:55.000Z","updated":"2017-05-04T08:04:11.000Z","comments":true,"path":"04/configure参数记录/","link":"","permalink":"/04/configure参数记录/","excerpt":"","text":"列表如下（部分参数未得到解释）： 指定 PHP 安装目录 --prefix=/usr/local/php 指定php.ini位置 --with-config-file-path=/usr/local/php/etc MySQL安装目录，对mysql的支持 --with-mysql=/usr/local/mysql mysqli扩展技术不仅可以调用MySQL的存储过程、处理MySQL事务，而且还可以使访问数据库工作变得更加稳定。 --with-mysqli=/usr/local/mysql/bin/mysql_config 整合 apache，apxs功能是使用mod_so中的LoadModule指令，加载指定模块到 apache，要求 apache 要打开SO模块 --with-apxs2=/usr/local/apache/bin/apxs 选项指令 –with-iconv-dir 用于 PHP 编译时指定 iconv 在系统里的路径，否则会扫描默认路径。 --with-iconv-dir=/usr/local --with-freetype-dir 打开对freetype字体库的支持 --with-jpeg-dir 打开对jpeg图片的支持 --with-png-dir 打开对png图片的支持 --with-zlib-dir 打开zlib库的支持，用于http压缩传输 --with-libxml-dir 打开libxml2库的支持 --disable-rpath 关闭额外的运行库文件 --enable-bcmath 打开图片大小调整,用到zabbix监控的时候用到了这个模块 --enable-shmop –enable-sysvsem 这样就使得你的PHP系统可以处理相关的IPC函数了。 --enable-inline-optimization 优化线程 --with-curl 打开curl浏览工具的支持 --with-curlwrappers 运用curl工具打开url流 --enable-mbregex --enable-fpm 打上PHP-fpm 补丁后才有这个参数，CGI方式安装的启动程序 --enable-mbstring 多字节，字符串的支持 --with-mcrypt mcrypt算法扩展 --with-mhash mhash算法扩展 --with-gd 打开gd库的支持 --enable-gd-native-ttf 支持TrueType字符串函数库 --with-openssl openssl的支持，加密传输https时用到的 --enable-pcntl freeTDS需要用到的，可能是链接mssql 才用到 --enable-sockets 打开 sockets 支持 --with-xmlrpc 打开xml-rpc的C语言 --enable-zip 打开对zip的支持 --enable-ftp 打开ftp的支持 --with-bz2 打开对bz2文件的支持 --without-iconv 关闭iconv函数，字符集间的转换 --with-ttf 打开freetype1.*的支持，可以不加了 --with-xsl 打开XSLT 文件支持，扩展了libXML2库 ，需要libxslt软件 --with-gettext 打开gnu 的gettext 支持，编码库用到 --with-pear 打开pear命令的支持，PHP扩展用的 --enable-calendar 打开日历扩展功能 --enable-exif 图片的元数据支持 --enable-magic-quotes 魔术引用的支持 --disable-debug 关闭调试模式--with-mime-magic=/usr/share/file/magic.mime 魔术头文件位置 CGI方式安装才用的参数 --enable-fastCGI 支持fastcgi方式启动PHP--enable-force-CGI-redirect 重定向方式启动PHP--with-ncurses 支持ncurses 屏幕绘制以及基于文本终端的图形互动功能的动态库--with-gmp 应该是支持一种规范--enable-dbase 建立DBA 作为共享模块--with-pcre-dir=/usr/local/bin/pcre-config perl的正则库案安装位置--disable-dmalloc--with-gdbm dba的gdbm支持--enable-sigchild--enable-sysvshm--enable-zend-multibyte 支持zend的多字节--enable-wddx--enable-soap","categories":[],"tags":[]},{"title":"PHP_UML创建项目类图","slug":"PHP-UML创建项目类图","date":"2017-05-04T06:35:00.000Z","updated":"2017-05-04T07:19:13.000Z","comments":true,"path":"04/PHP-UML创建项目类图/","link":"","permalink":"/04/PHP-UML创建项目类图/","excerpt":"","text":"PHP_UML可以用来将项目转化为xmi文件,再通过uml工具将其转化为UML PEAR环境配置若当前有不止一个php版本如7.0/5.5 使用php-version转换php版本1$ php-version 5.5.38 或修改用户根目录下.bashrc1source $(brew --prefix php-version)/php-version.sh &amp;&amp; php-version 5 之后重新加载配置1$ source ~/.bashrc 安装PEAR：12345678910$ sudo php /usr/lib/php/install-pear-nozlib.phar$ sudo pear config-set php_ini /usr/local/etc/php/5.5/php.ini$ sudo pear upgrade-all$ pear versionPEAR Version: 1.9.4PHP Version: 5.5.38Zend Engine Version: 2.5.0Running on: Darwin panduodeMacBook-Air.local 16.0.0 Darwin Kernel Version 16.0.0: Mon Aug 29 17:56:20 PDT 2016; root:xnu-3789.1.32~3/RELEASE_X86_64 x86_64 修改php.ini中include_path添加”:/usr/local/Cellar/php55/5.5.38_11/lib/php/pear”重启apache 安装PHP_UML1$ pear install PHP_UML 这里可能提示错误,需检查pear安装文件夹及缓存文件夹的权限,我的机器是在/usr/local/Cellar/php55/5.5.38_11/lib/php/pear 及 /private/tmp/pear/cache/ 改正权限再运行安装命令即可 生成XMI文件1phpuml ~/Sites/pf/ -o ~/Sites/pf.xmi -n pf -f xmi --pure-object --no-deployment-view --no-component-view --no-docblocks 生成UML使用支持xmi导入的工具如StarUML,导入xmi,生成UML文件即可","categories":[],"tags":[]},{"title":"测试文章","slug":"Hexo","date":"2017-05-02T08:50:04.000Z","updated":"2017-05-02T09:38:35.000Z","comments":true,"path":"02/Hexo/","link":"","permalink":"/02/Hexo/","excerpt":"","text":"Welcome to StackEdit! Hey! I’m your first Markdown document in StackEdit[^stackedit]. Don’t delete me, I’m very helpful! I can be recovered anyway in the Utils tab of the Settings dialog. Documents1234567891011121314function route(pathname,handle,response,request)&#123; console.log(\"About to route a request for \" + pathname); if(typeof handle[pathname] === 'function')&#123; return handle[pathname](response,request); &#125;else&#123; console.log(\"No request handler found for \" + pathname); response.writeHead(404, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"404 Not found\"); response.end(); &#125;&#125;exports.route = route; 123$ asdkjhfsjlkajdlkasd","categories":[],"tags":[]},{"title":"阻塞与同步","slug":"阻塞与同步","date":"2017-05-02T08:50:04.000Z","updated":"2017-05-02T09:06:31.000Z","comments":true,"path":"02/阻塞与同步/","link":"","permalink":"/02/阻塞与同步/","excerpt":"","text":"作者：严肃链接：https://www.zhihu.com/question/19732473/answer/20851256来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 “阻塞”与”非阻塞”与”同步”与“异步”不能简单的从字面理解，提供一个从分布式系统角度的回答。 1.同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication) 所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由调用者主动等待这个调用的结果。而异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。典型的异步编程模型比如Node.js举个通俗的例子：你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。 2.阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态. 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。还是上面的例子，你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。如果是关心blocking IO/ asynchronous IO, 参考 Unix Network Programming View Book 作者：愚抄链接：https://www.zhihu.com/question/19732473/answer/23434554来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 老张爱喝茶，废话不说，煮开水。出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。1 老张把水壶放到火上，立等水开。（同步阻塞）老张觉得自己有点傻2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。3 老张把响水壶放到火上，立等水开。（异步阻塞）老张觉得这样傻等意义不大4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）老张觉得自己聪明了。 所谓同步异步，只是对于水壶而言。普通水壶，同步；响水壶，异步。虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。所谓阻塞非阻塞，仅仅对于老张而言。立等的老张，阻塞；看电视的老张，非阻塞。情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-05-02T07:56:51.000Z","updated":"2017-05-02T07:56:51.000Z","comments":true,"path":"02/hello-world/","link":"","permalink":"/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}